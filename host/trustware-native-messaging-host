#!/usr/bin/env python
# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# A simple native messaging host. Shows a Tkinter dialog with incoming messages
# that also allows to send message back to the webapp.

import struct
import sys
import threading
import Queue

import json

import urllib
import urllib2

try:
  import lightblue
except ImportError:
  lightblue = None

try:
  import Tkinter
  import tkMessageBox
except ImportError:
  Tkinter = None

# On Windows, the default I/O mode is O_TEXT. Set this to O_BINARY
# to avoid unwanted modifications of the input/output streams.
if sys.platform == "win32":
  import os, msvcrt
  msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
  msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)

# Helper function that sends a message to the webapp.
def send_message(message):
  # Write message size.
  sys.stdout.write(struct.pack('I', len(message)))
  # Write the message itself.
  sys.stdout.write(message)
  sys.stdout.flush()

# Thread that reads messages from the webapp.
def read_thread_func(queue):
  message_number = 0
  while 1:
    # Read the message length (first 4 bytes).
    text_length_bytes = sys.stdin.read(4)

    if len(text_length_bytes) == 0:
      if queue:
        queue.put(None)
      sys.exit(0)

    # Unpack message length as 4 byte integer.
    text_length = struct.unpack('i', text_length_bytes)[0]

    # Read the text (JSON object) of the message.
    text = sys.stdin.read(text_length).decode('utf-8')

    if queue:
      queue.put(text)
    else:
      # In headless mode just send an echo message back.
      send_message('{"echo": %s}' % text)

if Tkinter:
  class NativeMessagingWindow(Tkinter.Frame):
    def __init__(self, queue):
      self.queue = queue

      Tkinter.Frame.__init__(self)
      self.pack()

      self.text = Tkinter.Text(self)
      self.text.grid(row=0, column=0, padx=10, pady=10, columnspan=2)
      self.text.config(state=Tkinter.DISABLED, height=10, width=40)

      self.messageContent = Tkinter.StringVar()
      self.sendEntry = Tkinter.Entry(self, text="token:", textvariable=self.messageContent)
      self.sendEntry.grid(row=1, column=0, padx=10, pady=10)

      self.urlContent = Tkinter.StringVar()
      self.urlEntry = Tkinter.Entry(self, text="url:", textvariable=self.urlContent)
      self.urlEntry.grid(row=2, column=0, padx=10, pady=10)

      self.sendButton = Tkinter.Button(self, text="Send", command=self.onSend)
      self.sendButton.grid(row=1, column=1, padx=10, pady=10)

      self.sendButton = Tkinter.Button(self, text="Bluetooth", command=self.getBluetooth)
      self.sendButton.grid(row=2, column=1, padx=10, pady=10)

      self.after(100, self.processMessages)

    def processMessages(self):
      while not self.queue.empty():
        message = self.queue.get_nowait()
        if message == None:
          self.quit()
          return
        self.log("Received %s" % message)

        json_acceptable_string = message.replace("'", "\"")
        d = json.loads(json_acceptable_string)

        self.onSend(d['token'], d['url'])

      self.after(100, self.processMessages)

    def getBluetooth(self):

      nearby_devices = lightblue.discover_devices(lookup_names = True)

      print "found %d devices" % len(nearby_devices)

      for name, addr in nearby_devices:
           print " %s - %s" % (addr, name)

    def onSend(self, _token=-1, _url=""):

      location = '/dev/otp'

      uid = 240454569 #default values
      otp = 0

      if _token != -1:
        token = _token 
      else:
        token = self.messageContent.get()

      if _url != "":
        url = _url
      else:
        url = self.urlContent.get()


      try:
        f = open(location, 'r')
        otp = f.read()
      except:
        tkMessageBox.showinfo('Native Messaging Example', 'problem reading'+location)
        #sys.exit(1)

      data = urllib.urlencode({'uid': uid ,'otp': otp, 'token': token, 'url': url})
      self.log('Sending %s' % data)

      try:
        url = "http://eecs588-auth.herokuapp.com/authenticate" #mock manufacture service
        #r = requests.post(url, data=json.dumps(data), headers=headers)
        r = urllib2.Request(url, data)
        response = urllib2.urlopen(r)

      except IOError as e:
        print e
        tkMessageBox.showinfo('Native Messaging Example', 'Failed to send message.')
        #sys.exit(1)

    def log(self, message):
      self.text.config(state=Tkinter.NORMAL)
      self.text.insert(Tkinter.END, message + "\n")
      self.text.config(state=Tkinter.DISABLED)


def Main():
  if not Tkinter:
    send_message('"Tkinter python module wasn\'t found. Running in headless ' +
                 'mode. Please consider installing Tkinter."')
    read_thread_func(None)
    sys.exit(0)

  queue = Queue.Queue()

  main_window = NativeMessagingWindow(queue)
  main_window.master.title('Device Info to Manufacturer')

  thread = threading.Thread(target=read_thread_func, args=(queue,))
  thread.daemon = True
  thread.start()

  main_window.mainloop()

  sys.exit(0)


if __name__ == '__main__':
  Main()
